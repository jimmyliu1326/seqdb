#!/usr/bin/env bash

script_usage() {

echo "
seqdb [subcommand] [options]

Available subcommands:
    build_db    construct a local sequence database
    unbuild_db  deconstruct a local sequence database
    extract     retrieve a target sequence from database
    remove      remove an existing target from database
    insert      add a new sequence to database
    replace     replace sequence of an existing target with a new sequence
    list        print all samples archived in a local sequence database to screen
    search      identify significant hits from an existing database given a query sequence
    build_tree  construct a cgSNP tree from closest genomic neighbours in the database
    kipper      interact with the data archive system

"
}

build_db_usage() {

echo "
seqdb build_db [options]

Required arguments:
-i|--input          Path to input parent directory with subfolders representing individual samples
-o|--output         Path to output sequence database

Optional arguments:
-h|--help           Display help message
"
}

unbuild_db_usage() {

echo "
seqdb unbuild_db [options]

Required arguments:
-i|--input          Path to input sequence database
-o|--output         Path to output parent directory with subfolders representing individual samples

Optional arguments:
-h|--help           Display help message
"
}

kipper_usage() {

echo "
seqdb kipper [options]

Required arguments:
-b|--backup         Do an incremental backup and create a new version of the archive database
-l|--list           List versions of the database
-r|--restore        Restore a copy of the archive database to a specific version
-v|--version        Version number (for -r restore)
-o|--output         Path to output sequence database (for -r restore)
-i|--input          Path to input sequence database (for -b backup)
-d|--database       Path to archive database (optional if remembered)

Optional arguments:
-h|--help           Display help message
"
}

extract_usage() {

echo "
seqdb extract [options]

Required arguments:
-q|--query      Query sample ID
-d|--db         Path to sequence database

Optional arguments:
-h|--help           Display help message
"
}

remove_usage() {

echo "
seqdb remove [options]

Required arguments:
-q|--query      Query sample ID
-d|--db         Path to sequence database

Optional arguments:
-h|--help       Display help message
"
}

replace_usage() {

echo "
seqdb replace [options]

Required arguments:
-q|--query      Query sample ID
-i|--input      Path to new sequence file in fasta format
-d|--db         Path to sequence database

Optional arguments:
-h|--help       Display help message
"
}

insert_usage() {

echo "
seqdb insert [options]

Required arguments:
-q|--query      Input sample ID
-i|--input      Path to input sequence file in fasta format
-d|--db         Path to sequence database

Optional arguments:
-h|--help       Display help message
"
}

search_usage() {

echo "
seqdb search [options]

Required arguments:
-q|--query      Input sample ID
-i|--input      Path to input sequence file in fasta format
-d|--db         Path to sequence database
-o|--output     Path to output results

Optional arguments:
-c|--cutoff     Filter results by a maximum distance cutoff [Default: 1] (Ranges from 0 to 1)
-t|--threads    Number of threads used [Default: 1]
-h|--help       Display help message
"
}

build_tree_usage() {

echo "
seqdb build_tree [options]

Required arguments:
-l|--list             List containing path to each query sequence per line (Must be absolute paths)
-o|--output           Path to output directory
-d|--db               Path to sequence database
-r|--reference        Path to reference sequence (not required with --fast_tree)
--linkage             Select method to define molecular linkage; Choices: [threshold, tophits, cluster]
                        threshold: use a universal distance threshold cutoff to define linkage
                        tophits: retrieve the top n number of hits ranked by genetic distances from low to high
                        cluster: use multi-dimensional density-based clustering to identify the closest related subpopulation

Optional arguments:
-t|--threads          Number of threads used [Default: 1]
--fast_tree           Construct K-mer distance tree instead of cgSNP tree
-c|--cutoff           Specify threshold cutoff to define molecular linkage
                        threshold: [0.001 by default]
                        tophits: [25 by default]

Optional arguments:
-h|--help             Display help message

"
}

list_usage() {

echo "
seqdb list [options]

Required arguments:
-d|--db             Path to sequence database

Optional arguments:
-h|--help           Display help message

"
}

# list all sample names archived in database
seqdb_list() {

    # $1 path to database

    # call seqkit and print all sample names to screen
    seqkit seq -ni $1 | sort -u
}

# identify sequences with molecular linkage to query
molecular_linkage() {

    # $1 mash results
    # $2 linkage method
    # $3 threshold cutoff
    # $4 output file
    # $5 number of threads

    if [[ $2 == threshold ]]; then
        awk -v var='$3' '{ if ($3 <= $var + 0) print $1 }' $1 > $4
    elif [[ $2 == tophits ]]; then
        head -n $3 $1 | cut -f1 -d' '> $4
    elif [[ $2 == cluster ]]; then
        $script_path/src/molecular_linkage.R $(dirname $1) $(basename $1) $4 $5
    fi
}

mash_sketch_db() {
    
    # $1 Sequence ID
    # $2 Database path
    # $3 k value
    extract $1 $2 > $(dirname $2)/sketches/$1.fa # extract sequence and save as tmp file
    echo "build_tree: Creating k = $3 sketch for $1"
    mash sketch -k $3 -s 10000 $(dirname $2)/sketches/$1.fa -o $(dirname $2)/sketches/$1.$3 2> /dev/null
    rm -rf $(dirname $2)/sketches/$1.fa # remove tmp file
}

# construct SNP tree from significant hits and query sequences
build_tree() {

    # $1    input list file
    # $2    path to output directory
    # $3    path to database
    # $4    path to reference sequence
    # $5    number of threads
    # $6    linkage method
    # $7    cutoff value
    # $8    run fast k-mer tree construction
    
    # set up output dir structure
            
    # clean up
    #if [[ $8 != "--fast_tree" ]]; then
        # rm -rf $2/phame
        # rm -rf $2/mash_res
        # rm -rf $2/phame.ctl
    #fi
    echo "build_tree: Phylogenetics workflow initiated..."
    echo "Workflow parameters:"
    echo "Query list: $1"
    echo "Output directory: $2"
    echo "Database path: $3"
    echo "Reference Seq: $4"
    echo "Threads: $5"
    echo "Linkage method: $6"
    echo "Cutoff value: $7"
    echo "Fast Tree: $8"

    mkdir -p $2/mash_res
    mkdir -p $2/plots
    mkdir -p $2/phame/ref_dir
    mkdir -p $2/phame/work_dir

    # configure mash database
    rm -rf $(dirname $3)/sketches # recreate mash sketches everytime
    mkdir -p $(dirname $3)/sketches
    if test -d $(dirname $3)/sketches; then
        # recreate database index
        rm ${3}.fai
        rm ${3}.seqkit.fai
        seqkit faidx -f $3
        
        echo "build_tree: Generating k-mer profile for database sequences..."
        #db_seq=$(seqkit seq -ni $3 | sort -u) # get all unique sample ids in DB

        # create mash sketches for each sample in DB
        # only create sketches at k=15:25 if linkage method is cluster
        if [[ $6 == "cluster" ]]; then
            k_array=(15 17 19 21 23 25)
        else
            k_array=( 21 )
        fi
        # do not recreate if already exists
        for k in ${k_array[@]}; do
            # export bash functions
            export -f extract
            export -f mash_sketch_db
            # run mash sketch in parallel
            #echo $db_seq | tr ' ' '\n' | parallel -j $5 "mash_sketch_db {} $3 $k"
            seqkit seq -ni $3 | sort -u | parallel -j $5 "mash_sketch_db {} $3 $k"
        done
    else
        echo "search: Mash sketches are not found in the same directory as the sequence database"; exit 1
    fi

    if test -f $1; then  
    # search for linked sequences
    # if query list exists, continue search
    # otherwise skip search and build tree from the entire database sequence
    echo "build_tree: Detected input query list $(realpath $1)"          
    echo "build_tree: Estimating k-mer distance between query and database seqs..."
    while read lines; do                
        if test -f $lines; then                
            # get filename
            filename=$(basename $lines)

            # estimate kmer distance
            if [[ $8 == --fast_tree ]]; then
                if [[ $6 == cluster ]]; then
                    k_array=(15 17 19 21 23 25)
                    for k in ${k_array[@]}; do
                        if [[ $k -ne 21 ]]; then
                            search ${filename%.*} $lines $3 $2/mash_res/${filename%.*}.$k.tsv 1 $5 $k
                        else
                            search ${filename%.*} $lines $3 $2/mash_res/${filename%.*}.$k.tsv 1 $5 21 --keep # only keep the 21-mer sketch for fast_tree construction
                        fi
                    done
                    mv $2/mash_res/${filename%.*}.21.msh $2/mash_res/${filename%.*}.msh # rename sketch file for fast_tree
                else # not cluster
                    search ${filename%.*} $lines $3 $2/mash_res/${filename%.*}.tsv 1 $5 21 --keep # only keep the 21-mer sketch for fast_tree construction
                    mv $2/mash_res/${filename%.*}.21.msh $2/mash_res/${filename%.*}.msh # rename sketch file for fast_tree
                fi
            else # not fast_tree
                if [[ $6 == cluster ]]; then
                    k_array=(15 17 19 21 23 25)
                    for k in ${k_array[@]}; do                 
                        search ${filename%.*} $lines $3 $2/mash_res/${filename%.*}.$k.tsv 1 $5 $k
                    done
                else # not cluster
                    search ${filename%.*} $lines $3 $2/mash_res/${filename%.*}.tsv 1 $5 21
                fi
            fi

            # identify molecularly linked sequences
            if [[ $6 == cluster ]]; then
                molecular_linkage $2/mash_res/${filename%.*} $6 $7 $2/mash_res/${filename%.*}.hits $5
            else
                molecular_linkage $2/mash_res/${filename%.*}.tsv $6 $7 $2/mash_res/${filename%.*}.hits
            fi
            # consolidate linked sequences, keep unique sequences only
            cat $2/mash_res/*.hits | sort -u | uniq > $2/linked_sequences.list
            echo "build_tree: $(wc -l $2/linked_sequences.list | cut -f1 -d' ') sequences found linked to query dataset"
        else
            echo "build_tree: the following file from the input list $1 was not found, exiting"
            echo "$lines"
            echo "Make sure the $1 file is in Unix format, not Windows (may need to use dos2unix command to convert)."
            exit 1
        fi
    done < $1
    # create linked_sequences.list from all seqs in db if no query list found
    else
    echo "build_tree: List of queries not found, building tree from the entire sequence database"
    seqkit seq -ni $3 | sort -u > $2/linked_sequences.list        
    fi

    # run SNP tree as default
    if [[ $8 != "--fast_tree" ]]; then
        ## set up input directory for SNP tree
        # query
        if test -f $1; then
        while read lines; do
            # get filename
            filename=$(basename $lines)
            if test -f $2/phame/work_dir/$filename; then
                rm $2/phame/work_dir/$filename
            fi
            ln -s $lines $2/phame/work_dir/$filename
        done < $1
        fi

        # database hits
        echo "build_tree: Extracting database sequences for tree building..."
        if [[ $(cat $2/linked_sequences.list | wc -l) -ne 0 ]]; then
            # parellize the sequence extract process
            export -f extract # export bash function
            cat $2/linked_sequences.list | parallel -j $5 "extract {} $3 > $2/phame/work_dir/{}.fasta"
        fi

        # reference sequence
        if test -f $4; then
            ln -s $(realpath $4) $2/phame/ref_dir/$(basename $4)
        else
            echo "build_tree: Input reference sequence was not found, exiting"; exit 1
        fi

        ## set up phame.ctl file
        echo "refdir = $(realpath $2)/phame/ref_dir" > $2/phame.ctl
        echo "workdir = $(realpath $2)/phame/work_dir" >> $2/phame.ctl
        echo "reference = 1" >> $2/phame.ctl
        echo "reffile = $(basename $4)" >> $2/phame.ctl
        echo "project = database_search" >> $2/phame.ctl
        echo "cdsSNPS = 0" >> $2/phame.ctl
        echo "buildSNPdb = 0" >> $2/phame.ctl
        echo "SNPsfilter = 0.6" >> $2/phame.ctl
        echo "FirstTime = 1" >> $2/phame.ctl
        echo "data = 3" >> $2/phame.ctl
        echo "reads = 1" >> $2/phame.ctl
        echo "aligner = minimap2" >> $2/phame.ctl
        echo "tree = 1" >> $2/phame.ctl
        echo "bootstrap = 1" >> $2/phame.ctl
        echo "N = 100" >> $2/phame.ctl
        echo "PosSelect = 0" >> $2/phame.ctl
        echo "code = 0" >> $2/phame.ctl
        echo "clean = 1" >> $2/phame.ctl
        echo "threads = $5" >> $2/phame.ctl
        echo "cutoff = 0.1" >> $2/phame.ctl

        # run phame
        echo "build_tree: Constructing cgSNP tree..."
        phame $2/phame.ctl

        if [[ $? != 0 ]]; then 
            echo "build_tree: Tree construction failed, check for error(s) above"
            exit 1
        fi

    else  # fast_tree
        # Run K-mer distance tree
        # set up input directory for mash tree
        if [[ $(wc -l $2/linked_sequences.list | cut -f1 -d' ') -ne 0 ]]; then
            while read lines; do
                ln -s $(dirname $(realpath $3))/sketches/$lines.21.msh $2/mash_res/$lines.msh
            
                # Create copies of real files if this is in the Windows file system.
                #cp $(realpath $(dirname $3))/sketches/$lines.msh $2/mash_res/$lines.msh
            done < $2/linked_sequences.list
        fi

        # run mashtree
        echo "build_tree: Constructing k-mer distance tree..."            
        mashtree --numcpus $5 $2/mash_res/*.msh > $2/tree.nwk
    fi    

    # write metadata file
    echo "build_tree: Writing metadata file..."
    echo "ID,status" > $2/metadata_microreact.csv # header line
    while read lines; do
        echo "${lines},reference" >> $2/metadata_microreact.csv
    done < $2/linked_sequences.list

    if test -f $1; then
    while read lines; do
        filename=$(basename $lines)
        echo "${filename%.*},query" >> $2/metadata_microreact.csv
    done < $1
    fi

    # sync sample names in metadata with names used in tree file
    # phame converts - or . characters in sample names to _
    if [[ $8 != "--fast_tree" ]]; then
    sed -i 's/-/_/g' $2/metadata_microreact.csv
    sed -i 's/\./_/g' $2/metadata_microreact.csv
    fi

    # clean up
    if test -f $2/phame/work_dir/results/trees/*.fasttree; then cp $2/phame/work_dir/results/trees/*.fasttree $2/tree.nwk; fi
    if test -f $2/phame; then rm -r $2/mash_res; fi
    if test -f $2/phame; then rm -r $2/phame; fi    
    if test -f $2/phame.ctl; then rm $2/phame.ctl; fi

    # print completion message
    echo "build_tree: Tree file written to: $2/tree.nwk"
    echo "build_tree: Microreact metadata file written to: $2/metadata_microreact.csv"
    echo "build_tree: $(wc -l $2/linked_sequences.list | cut -f1 -d' ') sequences found linked to query dataset"
    echo "build_tree: Complete"
}

# search database for hits
search() {

    # $1    input sample ID
    # $2    input sequence file path
    # $3    path to DB
    # $4    path to results
    # $5    distance cutoff
    # $6    threads
    # $7    k-value
    # $8    keep sketch
# eg search GCA_002055565.1 /c/Users/User/Downloads/complete_genomes/GCA_002055565.1.fna /data/amrDB/hpsuis/hpsuis_db.fasta /c/Temp//mash_res/GCA_002055565.1.tsv 1 1
    echo "search: Searching $1 against $3 with k = $7"

    if test -f $3; then
        if test -d $(dirname $3)/sketches; then
            if test -f $2; then

                # create query k-mer profile
                mash sketch -k $7 -s 10000 $2 -o $(dirname $4)/$1.$7 2> /dev/null

                # create empty output file
                if test -f $4; then rm $4; fi
                touch $4

                # estimate mash distance
                ls -d $(dirname $(realpath $3))/sketches/*.$7.msh | parallel -j $6 mash dist {} $(dirname $4)/${1}.$7.msh -d $5 -p 1 >> $4

                # remove query k-mer profile
                if [[ $8 != --keep ]]; then rm $(dirname $4)/$1.$7.msh; fi

                # reformat output
                awk 'gsub(/.*\//, "", $1)' $4 > $4.tmp && mv $4.tmp $4 # remove dir name in query
                awk 'gsub(/.*\//, "", $2)' $4 > $4.tmp && mv $4.tmp $4 # remove dir name in subject (database seqs)
                awk 'gsub(/\.[a-z]*$/, "", $1)' $4 > $4.tmp && mv $4.tmp $4 # remove the last extension in query path to get sample name
                awk 'gsub(/\.[a-z]*$/, "", $2)' $4 > $4.tmp && mv $4.tmp $4 # remove the last extension in subject path to get sample name
                sort -gk3 $4 > $4.tmp && mv $4.tmp $4 # sort by identity (column 3 in output file)

                echo "search: Output written to: $4"

            else
                echo "search: Path to input sequence file not found, exiting"; exit 1
            fi
        else
            echo "search: Mash sketches were not found in the same directory as the sequence database"; exit 1
        fi
    else
        echo "search: Path to database not found, exiting"; exit 1
    fi
}

# Use this to set the new config value for kipper archive database. 
function set_config(){
    echo "DB_PATH=\"$DB_PATH\"" > $cfgpath
    
    #sed -i "s/\($1 *= *\).*/\1$2/" $cfgpath
    #sed -i "s/^\($1\s*=\s*\).*\$/\1$2/" $cfgpath
}

# Show kipper db versions.
kipper_listdb() {

     # $1    database path including database name (*.fasta)
    # directory
    if [[ -d $1 ]]; then
        echo "kipper: Input path $1 is a directory, looking for *.fasta, exiting"
        exit 1
    fi

    $script_path/kipper/kipper.py $1 -l
}

# Perform archival functions.
kipper_backup() {

    # $1    input database path including database name (*.fasta)
    # $2    output sequence database

    ## check integrity of input file structure
    echo "kipper: Perform archival backup function..."

    # directory
    if [[ -d $1 ]]; then
        echo "kipper: Input path $1 is a directory, looking for *.fasta, exiting"
        exit 1
    fi
 
    # If the output database does not exist, create it.
    if [[ ! -f "$2.md" ]]; then
        $script_path/kipper/kipper.py $2 -M fasta
    fi

    foo="$script_path/kipper/kipper.py $2 -l"
    fooIn=$($foo)

    $script_path/kipper/kipper.py $2 -m -i $1 -o.
    
    fooOut=$($foo)
    if [ "$fooIn" = "$fooOut" ]; then
        echo "kipper: No changes"
    else
        echo "kipper: Backup complete"
    fi
}

# Perform restore function.
kipper_restore() {

    # $1    output sequence database path including database name (*.fasta)
    # $2    input archive database
    # $3    version number

    ## check integrity of input file structure
    echo "kipper: Perform archival restore function..."

    # directory
    if [[ -d $1 ]]; then
        echo "kipper: Output path $1 is a directory, looking for *.fasta, exiting"
        exit 1
    fi

    $script_path/kipper/kipper.py $2 -e -n $3 -o $1
}

# unbuild database
unbuild_db() {

    # $1    input database path including database name (*.fasta)
    # $2    output parent directory path

    ## check integrity of input file structure
    echo "unbuild_db: Checking integrity of input file structure..."

    # directory
    if [[ -d $1 ]]; then
        echo "unbuild_db: Input path is a directory, looking for *.fasta, exiting"
        exit 1
    fi

    # index database to make sure it is up-to-date, then use index to extract samples.
    seqkit faidx $1

    ## deconstruct db
    echo "unbuild_db: Deconstructing local sequence database from $1..."

    sed "s/\t/\|/g" < $1.fai | while read in; 
      do 
        sample=${in% *}
        # eg. 1616822_Hp
        id=${in#* }
        id=${id%% *}  
        # eg. contig_1_segment0

        if [[ ! -d $2/$sample ]]; then
            mkdir $2/$sample
        fi
        
        seqdb extract -q $sample -d $1 > $2/$sample/$id.fasta        
      done 

    echo "unbuild_db: Sample files built at $2"    
}

# build database
build_db() {

    # $1    input parent directory path or path with fasta file
    # $2    output database path

    ## check integrity of input file structure
    echo "build_db: Checking integrity of input file structure..."

    # remove database if exists
    if test -f $2; then
        echo "build_db: The specified output path exists, removing..."
        rm $2
    fi

    if test -d $(dirname $2)/sketches; then
        rm -rf $(dirname $2)/sketches
    fi

    echo "build_db: Constructing local sequence database..."
    mkdir -p $(dirname $2)/sketches

    # directory
    if [[ ! -d $1 ]]; then
        cat $1 >> $2

        #echo "build_db: Input path is not a directory, exiting"
        #exit 1
    else
      # subfolders
      samples_n=$(ls -d $1/*/ | wc -l)
      
      if [[ $samples_n -eq 0 ]]; then
          echo "build_db: No subfolders found under ${1}, exiting"
          exit 1
      else
          echo "build_db: Total samples found: $samples_n"
      fi

      ## construct sequence db    

      for dir in $(ls -d $1/*/); do
          # get sample id
          sample_id=$(echo $(basename $dir))

          # check fasta file
          if test -f $dir/$sample_id.fasta; then
              # append sample ID to fasta headers and insert entry to database
              cat $dir/$sample_id.fasta | sed "/>/ s/^>/>${sample_id}|/g" >> $2
              # create kmer profiles for k = 15,17,19,21,23,25
              k_array=(15 17 19 21 23 25)
              for k in ${k_array[@]}; do
                  mash sketch -k $k -s 10000 $dir/$sample_id.fasta -o $(dirname $2)/sketches/$sample_id.${k} 2> /dev/null
              done
          else
              echo "build_db: $sample_id.fasta not found under ${dir}, exiting"
              rm -rf $2
              rm -rf $(dirname $2)/sketches
              exit 1
          fi
      done
    fi 

    # index sequence database    
    seqkit faidx -f $2 # index

    echo "build_db: Local sequence database built at $2"    
}

extract() {

    # $1    Sample ID
    # $2    Database path
    
    if test -f $2; then
        # check sample ID
        #if [[ $(seqkit faidx -r $2 $1 | grep ">" | sed 's/;.*$//' | sed 's/>//' | awk -v var="$1" '$1==var' | wc -l) -eq 0 ]]; then
        if [[ $(seqkit grep -rp "${1}" $2 | grep ">" | wc -l) -eq 0 ]]; then
            # 1>&2 redirect echo output to stderr
            echo "extract: Query sample ID $1 not found, exiting" 1>&2
            exit 1
        else
            if test -f $2; then
                seqkit grep -rp "${1}" $2
                #seqkit grep -rp $1 $2 | seqkit fx2tab | awk 'BEGIN{FS=OFS="\t"} {$1 = $1 OFS $1} 1' | awk 'BEGIN{FS=OFS="\t"} {gsub(/;.*/,"",$1); print}' | awk -v var="$1" '$1==var' | cut -f1 --complement -d$'\t' | seqkit tab2fx
            else
                echo "extract: Path to Database $2 does not exist, exiting" 1>&2
                exit 1
            fi
        fi
    else
        echo "extract: Path to Database $2 does not exist, exiting" 1>&2
        exit 1
    fi
}

insert() {

    # $1 Sample ID
    # $2 Input FASTA path
    # $3 Database path

    if test -f $3; then
        # check sample ID
        #if [[ $(seqkit faidx -r $3 $1 | grep ">" | sed 's/;.*$//' | sed 's/>//' | awk -v var="$1" '$1==var' | wc -l) -eq 0 ]]; then
        if [[ $(seqkit faidx -r $3 "${1}" | grep ">" | wc -l) -eq 0 ]]; then
            if test -f $2; then
                
                # sketch k-mer profile for insert
                if test -d $(dirname $3)/sketches; then
                    echo "insert: Generating k-mer profile for $1"
                    k_array=(15 17 19 21 23 25)
                    for k in ${k_array[@]}; do
                        mash sketch -k $k -s 10000 $2 -o $(dirname $3)/sketches/$1.${k} 2> /dev/null
                    done
                else
                    echo "insert: k-mer sketches directory is not found in the same directory as the input database at $(realpath $(dirname $3)), exiting"; exit 1
                fi

                echo "insert: Inserting $1 from $2 into $3"
                cat $2 | sed "/>/ s/^>/>$1 /g" >> $3
                # Invalidate the index by deleting it.
                rm $3.fai

                # reformat database to ensure equal lengths across entries
                picard NormalizeFasta -I $3 -O $3.tmp > /dev/null
                mv $3.tmp $3

                # index 
                seqkit faidx $3

                echo "insert: Complete"
            else
                echo "insert: Input FASTA file not found, exiting"
                exit 1
            fi
        else
            echo "insert: The input sample ID already exists in the database, use replace subcommand instead, exiting"
            exit 1
        fi
    else
        echo "insert: Path to Database $3 does not exist, exiting"
        exit 1
    fi
}

remove() {

    # $1 Sample ID
    # $2 Database path

    if test -f $2; then
        if [[ $(seqkit faidx -r $2 "${1}" | grep ">" | wc -l) -eq 0 ]]; then
            echo "remove: Query sample ID not found, exiting"
            exit 1
        else
            echo "remove: Deleting $1 from $2"
            
            if test -d $(dirname $2)/sketches; then
                rm $(dirname $2)/sketches/$1.*.msh
            else
                echo "remove: k-mer sketches directory is not found in the same directory as the input database at $(realpath $(dirname $3)), exiting"; exit 1
            fi
            
            seqkit grep -v -rp "${1}" $2 > tmp.fasta
            # $2 gets set to zero length if redirected directly.
            mv tmp.fasta $2
            # Invalidate the index by deleting it.
            rm $2.fai

            echo "remove: Complete"            
        fi
    else
        echo "remove: Path to Database $2 does not exist, exiting"
        exit 1
    fi
}

replace() {

    # $1 Sample ID
    # $2 Input FASTA path
    # $3 Database path

    echo "replace: Modifying $1 in $3"
    remove $1 $3
    insert $1 $2 $3
}

# parse arguments
if [[ $# -eq 0 || $1 =~ ^(--help|-h) ]]; then
    script_usage
    exit 0
elif [[ ! $1 =~ ^(extract|build_db|remove|replace|insert|unbuild_db|kipper|search|build_tree|list)$ ]]; then
    echo "Invalid subcommand given"
    script_usage
    exit 1
fi

#cd # Run from home directory.

## check dependencies
script_path=$(echo $(dirname $0))

# seqkit
seqkit -h > /dev/null
if [[ $(echo $?) -ne 0 ]]; then
    echo "Seqkit cannot be called, check its installation, exiting"
    exit 1
fi
# mash
#conda run -n mash-2.2.2 mash sketch -h > /dev/null
mash sketch -h > /dev/null
if [[ $(echo $?) -ne 0 ]]; then
    echo "mash cannot be called, check its installation, exiting"
    exit 1
fi
# picard
picard -h 2> /dev/null
if [[ $(echo $?) -ne 1 ]]; then
    echo "picard cannot be called, check its installation, exiting"
    exit 1
fi

# kipper
# Jan-5-2022 [ab] kipper no longer used.
#${script_path}/kipper/kipper.py -h > /dev/null
#if [[ $(echo $?) -ne 0 ]]; then
    #echo "kipper cannot be called, check its installation, exiting"
    #exit 1
#fi

# phame
phame -h > /dev/null
if [[ $(echo $?) -ne 0 ]]; then
    echo "phame cannot be called, check its installation, exiting"
    exit 1
fi
# mashtree
mashtree -h > /dev/null
if [[ $(echo $?) -ne 0 ]]; then
    echo "mashtree cannot be called, check its installation, exiting"
    exit 1
fi

# parse subcommands
if [[ $1 == "build_db" ]]; then
    shift 1
    if [[ $# -eq 0 ]]; then
        build_db_usage
        exit 0
    fi
    opts=`getopt -o hi:o: -l help,input:,output: -- "$@"`
    eval set -- "$opts"
    if [ $? != 0 ] ; then echo "build_db: Invalid arguments used, exiting"; build_db_usage; exit 1 ; fi
    if [[ $1 =~ ^--$ ]] ; then echo "build_db: Invalid arguments used, exiting"; build_db_usage; exit 1 ; fi

    while true; do
        case "$1" in
            -i|--input) INPUT_PATH=$2; shift 2;;
            -o|--output) OUTPUT_PATH=$2; shift 2;;
            --) shift; break ;;
            -h|--help) build_db_usage; exit 0;;
        esac
    done

    # check if required arguments present
    if [[ -z $INPUT_PATH ]]; then
        echo "build_db: required argument -i is missing, exiting"; build_db_usage; exit 1
    elif [[ -z $OUTPUT_PATH ]]; then
        echo "build_db: required argument -o is missing, exiting"; build_db_usage; exit 1
    fi
    # call build_db function
    build_db $INPUT_PATH $OUTPUT_PATH    
elif 
[[ $1 == "unbuild_db" ]]; then
    shift 1
    if [[ $# -eq 0 ]]; then
        unbuild_db_usage
        exit 0
    fi
    opts=`getopt -o hi:o: -l help,input:,output: -- "$@"`
    if [ $? != 0 ] ; then echo "unbuild_db: Invalid arguments used, exiting"; unbuild_db_usage; exit 1 ; fi
    eval set -- "$opts"
    if [[ $1 =~ ^--$ ]] ; then echo "unbuild_db: Invalid arguments used, exiting"; unbuild_db_usage; exit 1 ; fi

    while true; do
        case "$1" in
            -i|--input) INPUT_PATH=$2; shift 2;;
            -o|--output) OUTPUT_PATH=$2; shift 2;;
            --) shift; break ;;
            -h|--help) unbuild_db_usage; exit 0;;
        esac
    done

    # check if required arguments present
    if [[ -z $INPUT_PATH ]]; then
        echo "unbuild_db: required argument -i is missing, exiting"; unbuild_db_usage; exit 1
    elif  [[ -z $OUTPUT_PATH ]]; then
        echo "unbuild_db: required argument -o is missing, exiting"; unbuild_db_usage; exit 1
    fi 
    # call unbuild_db function
    unbuild_db $INPUT_PATH $OUTPUT_PATH
elif 
[[ $1 == "kipper" ]]; then
    shift 1
    if [[ $# -eq 0 ]]; then
        kipper_usage
        exit 0
    fi
    opts=`getopt -o hblri:v:o:d: -l help,backup,list,restore,input:,version:,output:,database: -- "$@"`
    if [ $? != 0 ] ; then echo "kipper: Invalid arguments used, exiting"; kipper_usage; exit 1 ; fi
    eval set -- "$opts"
    if [[ $1 =~ ^--$ ]] ; then echo "kipper: Invalid arguments used, exiting"; kipper_usage; exit 1 ; fi

    backup=false
    listdb=false
    restore=false
    while true; do
        case "$1" in
            -i|--input) INPUT_PATH=$2; shift 2;;
            -o|--output) OUTPUT_PATH=$2; shift 2;;
            -d|--database) DB_PATH=$2; shift 2;;
            -v|--version) VERSION=$2; shift 2;;
            --) shift; break ;;
            -h|--help) kipper_usage; exit 0;;
            -b|--backup) backup=true; shift 1;;
            -r|--restore) restore=true; shift 1;;
            -l|--list) listdb=true; shift 1;;
        esac
    done

    if [ "$listdb" = true ]; then
        # check if required arguments present
        if [[ -z $DB_PATH ]]; then
            echo "kipper: required argument -d is missing, exiting"; kipper_usage; exit 1
        fi 

        # call kipper backup function
        kipper_listdb $DB_PATH 
    fi

    if [ "$backup" = true ]; then
        # check if required arguments present
        if [[ -z $INPUT_PATH ]]; then
            echo "kipper: required argument -i is missing, exiting"; kipper_usage; exit 1
        elif  [[ -z $DB_PATH ]]; then
            # TODO: first look for remembered db path and use if available.
            cfgpath=$(dirname $INPUT_PATH)"/kipper.cfg"

            # INITIALIZE CONFIG IF IT'S MISSING
            if [ ! -e "${cfgpath}" ] ; then
                echo "kipper: required argument -d is missing, exiting"; kipper_usage; exit 1
            fi
        fi 

        cfgpath=$(dirname $INPUT_PATH)"/kipper.cfg"
        if [ ! -e "${cfgpath}" ] ; then
            # Set default variable value
            touch $cfgpath
            echo "DB_PATH=\"$DB_PATH\"" > $cfgpath
        fi

        if  [[ -z $DB_PATH ]]; then
            # LOAD FROM THE CONFIG FILE
            source $cfgpath
            if [[ -z $DB_PATH ]]; then
                echo "kipper: required argument -d is missing from config file $cfgpath, exiting"; kipper_usage; exit 1
            fi
        fi
        set_config "DB_PATH" $DB_PATH # SETS THE NEW VALUE         
        
        # call kipper backup function
        #echo "Call Kipper $DB_PATH -i $INPUT_PATH -o."
        kipper_backup $INPUT_PATH $DB_PATH 
    fi

    if [ "$restore" = true ]; then
        # check if required arguments present
        if [[ -z $OUTPUT_PATH ]]; then
            echo "kipper: required argument -o is missing, exiting"; kipper_usage; exit 1
        fi
        if [[ -z $VERSION ]]; then
            echo "kipper: required argument -v is missing, exiting"; kipper_usage; exit 1
        fi
                
        # call kipper restore function
        echo "Restoring Kipper $DB_PATH version $VERSION to $OUTPUT_PATH."
        kipper_restore $OUTPUT_PATH $DB_PATH $VERSION
    fi

elif [[ $1 == "extract" ]]; then
    shift 1
    if [[ $# -eq 0 ]]; then
        extract_usage
        exit 0
    fi
    opts=`getopt -o hq:d: -l help,db:,query: -- "$@"`
    eval set -- "$opts"
    if [ $? != 0 ] ; then echo "extract: Invalid arguments used, exiting"; extract_usage; exit 1 ; fi
    if [[ $1 =~ ^--$ ]] ; then echo "extract: Invalid arguments used, exiting"; extract_usage; exit 1 ; fi

    while true; do
        case "$1" in
            -q|--query) QUERY=$2; shift 2;;
            -d|--db) DB_PATH=$2; shift 2;;
            --) shift; break ;;
            -h|--help) extract_usage; exit 0;;
        esac
    done

    # check if required arguments present
    if [[ -z $QUERY ]]; then
        echo "extract: required argument -q is missing, exiting"; extract_usage; exit 1
    elif [[ -z $DB_PATH ]]; then
        echo "extract: required argument -d is missing, exiting"; extract_usage; exit 1
    fi
    # call extract function
    extract $QUERY $DB_PATH

elif [[ $1 == "remove" ]]; then
    shift 1
    if [[ $# -eq 0 ]]; then
        remove_usage
        exit 0
    fi
    opts=`getopt -o hq:d: -l help,db:,query: -- "$@"`
    eval set -- "$opts"
    if [ $? != 0 ] ; then echo "remove: Invalid arguments used, exiting"; remove_usage; exit 1 ; fi
    if [[ $1 =~ ^--$ ]] ; then echo "remove: Invalid arguments used, exiting"; remove_usage; exit 1 ; fi

    while true; do
        case "$1" in
            -q|--query) QUERY=$2; shift 2;;
            -d|--db) DB_PATH=$2; shift 2;;
            --) shift; break ;;
            -h|--help) remove_usage; exit 0;;
        esac
    done

    # check if required arguments present
    if [[ -z $QUERY ]]; then 
        echo "remove: required argument -q is missing, exiting"; remove_usage; exit 1
    elif [[ -z $DB_PATH ]]; then
        echo "remove: required argument -d is missing, exiting"; remove_usage; exit 1;
    fi
    # call remove function
    remove $QUERY $DB_PATH

elif [[ $1 == "insert" ]]; then
    shift 1
    if [[ $# -eq 0 ]]; then
        insert_usage
        exit 0
    fi
    opts=`getopt -o hq:d:i: -l help,db:,query:,input: -- "$@"`
    eval set -- "$opts"
    if [ $? != 0 ] ; then echo "insert: Invalid arguments used, exiting"; insert_usage; exit 1 ; fi
    if [[ $1 =~ ^--$ ]] ; then echo "insert: Invalid arguments used, exiting"; insert_usage; exit 1 ; fi

    while true; do
        case "$1" in
            -q|--query) QUERY=$2; shift 2;;
            -d|--db) DB_PATH=$2; shift 2;;
            -i|--input) INPUT_PATH=$2; shift 2;;
            --) shift; break ;;
            -h|--help) insert_usage; exit 0;;
        esac
    done

    # check if required arguments present
    if [[ -z $QUERY ]]; then
        echo "insert: required argument -q is missing, exiting"; insert_usage; exit 1
    elif [[ -z $DB_PATH ]]; then 
        echo "insert: required argument -d is missing, exiting"; insert_usage; exit 1
    elif [[ -z $INPUT_PATH ]]; then
        echo "insert: required argument -i is missing, exiting"; insert_usage; exit 1
    fi
    # call insert function
    insert $QUERY $INPUT_PATH $DB_PATH

elif [[ $1 == "replace" ]]; then
    shift 1
    if [[ $# -eq 0 ]]; then
        replace_usage
        exit 0
    fi
    opts=`getopt -o hq:d:i: -l help,db:,query:,input: -- "$@"`
    eval set -- "$opts"
    if [ $? != 0 ] ; then echo "replace: Invalid arguments used, exiting"; replace_usage; exit 1 ; fi
    if [[ $1 =~ ^--$ ]] ; then echo "replace: Invalid arguments used, exiting"; replace_usage; exit 1 ; fi

    while true; do
        case "$1" in
            -q|--query) QUERY=$2; shift 2;;
            -d|--db) DB_PATH=$2; shift 2;;
            -i|--input) INPUT_PATH=$2; shift 2;;
            --) shift; break ;;
            -h|--help) replace_usage; exit 0;;
        esac
    done

    # check if required arguments present
    if [[ -z $QUERY ]]; then 
        echo "replace: required argument -q is missing, exiting"; replace_usage; exit 1
    elif [[ -z $DB_PATH ]]; then
        echo "replace: required argument -d is missing, exiting"; replace_usage; exit 1
    elif [[ -z $INPUT_PATH ]]; then 
        echo "replace: required argument -i is missing, exiting"; replace_usage; exit 1
    fi

    # call replace function
    replace $QUERY $INPUT_PATH $DB_PATH

elif [[ $1 == "search" ]]; then
    shift 1
    if [[ $# -eq 0 ]]; then
        search_usage
        exit 0
    fi
    opts=`getopt -o hq:d:i:o:c:t: -l help,db:,query:,input:,output:,cutoff:,threads: -- "$@"`
    eval set -- "$opts"
    if [ $? != 0 ] ; then echo "search: Invalid arguments used, exiting"; search_usage; exit 1 ; fi
    if [[ $1 =~ ^--$ ]] ; then echo "search: Invalid arguments used, exiting"; search_usage; exit 1 ; fi

    while true; do
        case "$1" in
            -q|--query) QUERY=$2; shift 2;;
            -d|--db) DB_PATH=$2; shift 2;;
            -i|--input) INPUT_PATH=$2; shift 2;;
            -o|--output) OUTPUT_PATH=$2; shift 2;;
            -c|--cutoff) CUTOFF=$2; shift 2;;
            -t|--threads) THREADS=$2; shift 2;;
            --) shift; break ;;
            -h|--help) search_usage; exit 0;;
        esac
    done

    # check if required arguments present
    if [[ -z $QUERY ]]; then 
        echo "search: required argument -q is missing, exiting"; search_usage; exit 1
    elif [[ -z $DB_PATH ]]; then
        echo "search: required argument -q is missing, exiting"; search_usage; exit 1
    elif [[ -z $INPUT_PATH ]]; then 
        echo "search: required argument -i is missing, exiting"; search_usage; exit 1
    elif [[ -z $OUTPUT_PATH ]]; then 
        echo "search: required argument -o is missing, exiting"; search_usage; exit 1
    fi

    if [[ -z $CUTOFF ]]; then CUTOFF=1; fi
    if [[ -z $THREADS ]]; then THREADS=1; fi

    # call search function
    search $QUERY $INPUT_PATH $DB_PATH $OUTPUT_PATH $CUTOFF $THREADS 21
elif [[ $1 == "build_tree" ]]; then
    shift 1
    if [[ $# -eq 0 ]]; then
        build_tree_usage
        exit 0
    fi
    opts=`getopt -o hd:l:o:t:r:n:c: -l help,db:,list:,output:,threads:,reference:,fast_tree,linkage:,cutoff:,include_all -- "$@"`
    eval set -- "$opts"
    if [ $? != 0 ] ; then echo "build_tree: Invalid arguments used, exiting"; build_tree_usage; exit 1 ; fi
    if [[ $1 =~ ^--$ ]] ; then echo "build_tree: Invalid arguments used, exiting"; build_tree_usage; exit 1 ; fi

    while true; do
        case "$1" in
            -l|--list) INPUT_LIST=$2; shift 2;;
            -d|--db) DB_PATH=$2; shift 2;;
            -o|--output) OUTPUT_DIR=$2; shift 2;;
            -t|--threads) THREADS=$2; shift 2;;
            -r|--reference) REF_PATH=$2; shift 2;;
            --linkage) LINKAGE=$2; shift 2;;
            --fast_tree) FAST_TREE=true; shift 1;;
            -c|--cutoff) CUTOFF=$2; shift 2;;
            --include_all) ALL=true; shift 1;;
            --) shift; break ;;
            -h|--help) build_tree_usage; exit 0;;
        esac
    done

    # check if required arguments present
    if [[ -z $DB_PATH ]]; then echo "build_tree: required argument -d is missing, exiting"; build_tree_usage; exit 1; fi
    if [[ -z $OUTPUT_DIR ]]; then echo "build_tree: required argument -o is missing, exiting"; build_tree_usage; exit 1; fi
    # ref path is required if not invoking --fast_tree
    if [[ -z $REF_PATH ]] && [[ $FAST_TREE != true ]]; then echo "build_tree: required argument -r is missing, exiting"; build_tree_usage; exit 1; fi
    # linkage option is required if input list is provided and --include-all is not invoked
    if [[ -f $INPUT_LIST ]] && [[ $ALL != 'true' ]]; then
        if [[ -z $LINKAGE ]]; then echo "build_tree: required argument --linkage is missing, exiting"; build_tree_usage; exit 1; fi
        if [[ ! $LINKAGE =~ ^(threshold|cluster|tophits)$ ]]; then echo "build_tree: invalid linkage method passed to the --linkage argument, exiting"; build_tree_usage; exit 1; fi
        # if linkage option is either threshold/tophits, cutoff value is required
        if [[ $LINKAGE =~ ^(threshold|tophits)$ ]] && [[ -z $CUTOFF ]]; then echo "build_tree: required argument -c is missing, exiting"; build_tree_usage; exit 1; fi
    fi
    
    # initialize variables with default values
    if [[ -z $THREADS ]]; then THREADS=1; fi
    if [[ $LINKAGE == threshold ]] && [[ -z $CUTOFF ]]; then CUTOFF=0.005; fi
    if [[ $LINKAGE == tophits ]] && [[ -z $CUTOFF ]]; then CUTOFF=25; fi
    if [[ $LINKAGE == cluster ]] && [[ -z $CUTOFF ]]; then CUTOFF=0; fi
    if [[ $ALL == true ]]; then CUTOFF=1; LINKAGE=threshold; fi
    if [[ -z $INPUT_LIST ]] || [[ ! -f $INPUT_LIST ]]; then INPUT_LIST=empty; LINKAGE=empty; CUTOFF=empty; fi

    # call build_tree function
    if [[ $FAST_TREE == true ]]; then
        REF_PATH=empty
        build_tree $INPUT_LIST $OUTPUT_DIR $DB_PATH $REF_PATH $THREADS $LINKAGE $CUTOFF --fast_tree
    else
        build_tree $INPUT_LIST $OUTPUT_DIR $DB_PATH $REF_PATH $THREADS $LINKAGE $CUTOFF
    fi

elif [[ $1 == "list" ]]; then
    shift 1
    if [[ $# -eq 0 ]]; then
        list_usage
        exit 0
    fi
    opts=`getopt -o hd: -l help,db: -- "$@"`
    eval set -- "$opts"
    if [ $? != 0 ] ; then echo "list: Invalid arguments used, exiting"; list_usage; exit 1 ; fi
    if [[ $1 =~ ^--$ ]] ; then echo "list: Invalid arguments used, exiting"; list_usage; exit 1 ; fi

    while true; do
        case "$1" in
            -d|--db) DB_PATH=$2; shift 2;;
            --) shift; break ;;
            -h|--help) list_usage; exit 0;;
        esac
    done

    # check if required arguments present
    if [[ -z $DB_PATH ]]; then
        echo "list: required argument -d is missing, exiting"; list_usage; exit 1
    fi
    # call seqdb_list function
    seqdb_list $DB_PATH
fi