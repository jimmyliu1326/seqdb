#!/usr/bin/env bash

script_usage() {

echo "
seqdb [subcommand] [options]

Available subcommands:
    build_db    construct a local sequence database
    unbuild_db  deconstruct a local sequence database
    extract     retrieve a target sequence from database
    remove      remove an existing target from database
    insert      add a new sequence to database
    replace     replace sequence of an existing target with a new sequence
    search      identify significant hits from an existing database given a query sequence
    build_tree  construct a cgSNP tree from closest genomic neighbours in the database
    kipper      interact with the data archive system
"
}

build_db_usage() {

echo "
seqdb build_db [options]

Required arguments:
-i|--input          Path to input parent directory with subfolders representing individual samples
-o|--output         Path to output sequence database

Optional arguments:
-h|--help   Display help message
"
}

unbuild_db_usage() {

echo "
seqdb unbuild_db [options]

Required arguments:
-i|--input          Path to input sequence database
-o|--output         Path to output parent directory with subfolders representing individual samples

Optional arguments:
-h|--help   Display help message
"
}

kipper_usage() {

echo "
seqdb kipper [options]

Required arguments:
-b|--backup         Do an incremental backup and create a new version of the archive database
-l|--list           List versions of the database
-r|--restore        Restore a copy of the archive database to a specific version
-v|--version        Version number (for -r restore)
-o|--output         Path to output sequence database (for -r restore)
-i|--input          Path to input sequence database (for -b backup)
-d|--database       Path to archive database (optional if remembered)

Optional arguments:
-h|--help   Display help message
"
}

extract_usage() {

echo "
seqdb extract [options]

Required arguments:
-q|--query      Query sample ID
-d|--db         Path to sequence database
"
}

remove_usage() {

echo "
seqdb remove [options]

Required arguments:
-q|--query      Query sample ID
-d|--db         Path to sequence database
"
}

replace_usage() {

echo "
seqdb replace [options]

Required arguments:
-q|--query      Query sample ID
-i|--input      Path to new sequence file in fasta format
-d|--db         Path to sequence database
"
}

insert_usage() {

echo "
seqdb insert [options]

Required arguments:
-q|--query      Input sample ID
-i|--input      Path to input sequence file in fasta format
-d|--db         Path to sequence database
"
}

search_usage() {

echo "
seqdb search [options]

Required arguments:
-q|--query      Input sample ID
-i|--input      Path to input sequence file in fasta format
-d|--db         Path to sequence database
-o|--output     Path to output results

Optional arguments:
-c|--cutoff     Filter results by a maximum distance cutoff [Default: 1] (Ranges from 0 to 1)
-t|--threads    Number of threads used [Default: 1]
"
}

build_tree_usage() {

echo "
seqdb build_tree [options]

Required arguments:
-l|--list             List containing path to each query sequence per line (Must be absolute paths)
-o|--output           Path to output directory
-d|--db               Path to sequence database
-r|--reference        Path to reference sequence (required for cgSNP tree)

Optional arguments:
-t|--threads          Number of threads used [Default: 1]
-n                    Number of top hits to include per query [Default: 50]
--fast_tree           Construct K-mer distance tree instead of cgSNP tree

"
}

# construct SNP tree from significant hits and query sequences
build_tree() {

    # $1    input list file
    # $2    path to output directory
    # $3    path to database
    # $4    path to reference sequence
    # $5    number of threads
    # $6    number of hits to include per query
    # $7    run fast k-mer tree construction

    # set up output dir structure
    mkdir -p $2/mash_res
    mkdir -p $2/phame/ref_dir
    mkdir -p $2/phame/work_dir

    # search for top hits
    if test -f $1; then

        echo "build_tree: Estimating k-mer distance..."
        while read lines; do
            if test -f $lines; then
            
                # get filename
                filename=$(basename $lines)

                # estimate kmer distance
                if [[ $7 == --fast_tree ]]; then
                    search ${filename%.*} $lines $3 $2/mash_res/${filename%.*}.tsv 1 $5 --keep > /dev/null
                else
                    search ${filename%.*} $lines $3 $2/mash_res/${filename%.*}.tsv 1 $5 > /dev/null
                fi

                # filter top hits
                head -n $6 $2/mash_res/${filename%.*}.tsv | cut -f1 -d' ' > $2/mash_res/${filename%.*}.hits
            else
                echo "build_tree: $lines from the input list was not found, exiting"; exit 1
            fi
        done < $1

        # consolidate top hits, keep unique hits only
        cat $2/mash_res/*.hits | sort -u | uniq > $2/db_top_hits.list

        # run SNP tree as default
        if [[ $7 != --fast_tree ]]; then
            ## set up input directory for SNP tree
            # query
            while read lines; do
                # get filename
                filename=$(basename $lines)
                ln -s $lines $2/phame/work_dir/$filename
            done < $1

            # database hits
            while read lines; do
                # get sequence from database
                extract $lines $3 > $2/phame/work_dir/$lines.fasta
            done < $2/db_top_hits.list

            # reference sequence
            if test -f $4; then
                ln -s $(realpath $4) $2/phame/ref_dir/$(basename $4)
            else
                echo "build_tree: Input reference sequence was not found, exiting"; exit 1
            fi

            ## set up phame.ctl file
            echo "refdir = $(realpath $2)/phame/ref_dir" > $2/phame.ctl
            echo "workdir = $(realpath $2)/phame/work_dir" >> $2/phame.ctl
            echo "reference = 1" >> $2/phame.ctl
            echo "reffile = $(basename $4)" >> $2/phame.ctl
            echo "project = database_search" >> $2/phame.ctl
            echo "cdsSNPS = 0" >> $2/phame.ctl
            echo "buildSNPdb = 0" >> $2/phame.ctl
            echo "SNPsfilter = 0.6" >> $2/phame.ctl
            echo "FirstTime = 1" >> $2/phame.ctl
            echo "data = 3" >> $2/phame.ctl
            echo "reads = 1" >> $2/phame.ctl
            echo "aligner = minimap2" >> $2/phame.ctl
            echo "tree = 1" >> $2/phame.ctl
            echo "bootstrap = 1" >> $2/phame.ctl
            echo "N = 100" >> $2/phame.ctl
            echo "PosSelect = 0" >> $2/phame.ctl
            echo "code = 0" >> $2/phame.ctl
            echo "clean = 1" >> $2/phame.ctl
            echo "threads = $5" >> $2/phame.ctl
            echo "cutoff = 0.1" >> $2/phame.ctl

            # run phame
            echo "build_tree: Constructing cgSNP tree..."
            phame $2/phame.ctl

            # clean up
            mv $2/phame/work_dir/results/trees/*.fasttree $2/tree.nwk
            rm -rf $2/phame
            rm -rf $2/mash_res
            rm $2/db_top_hits.list
            rm $2/phame.ctl
        else
            # Run K-mer distance tree
            # set up input directory for mash tree
            while read lines; do
                ln -s $(realpath $(dirname $3))/sketches/$lines.msh $2/mash_res/$lines.msh
            done < $2/db_top_hits.list

            # run mashtree
            echo "build_tree: Constructing k-mer distance tree..."
            mashtree --numcpus $5 $2/mash_res/*.msh > $2/tree.nwk

            # clean up
            rm -rf $2/mash_res
            rm -rf $2/phame
            rm $2/db_top_hits.list
        fi        

    else
        echo "build_tree: Input list was not found, exiting"; exit 1
    fi   
}

# search database for hits
search() {

    # $1    input sample ID
    # $2    input sequence file path
    # $3    path to DB
    # $4    path to results
    # $5    distance cutoff
    # $6    threads
    # $7    keep sketch

    echo "search: Searching $1 against $3"

    if test -f $3; then
        if test -d $(dirname $3)/sketches; then
            if test -f $2; then

                # create query k-mer profile
                mash sketch -s 10000 $2 -o $(dirname $4)/$1 2> /dev/null

                # create empty output file
                touch $4

                # estimate mash distance
                for sketch in $(dirname $3)/sketches/*.msh; do
                    mash dist $sketch $(dirname $4)/$1.msh -d $5 -p $6 >> $4
                done

                # remove query k-mer profile
                if [[ $7 != --keep ]]; then rm $(dirname $4)/$1.msh; fi

                # format output
                awk 'gsub(/.*\//, "", $1)' $4 > $4.tmp && mv $4.tmp $4
                awk 'gsub(/.*\//, "", $2)' $4 > $4.tmp && mv $4.tmp $4
                sed -e 's/.fasta//g' -e 's/.fna//g' -e 's/.fa//g' $4 > $4.tmp && mv $4.tmp $4
                sort -gk3 $4 > $4.tmp && mv $4.tmp $4

                echo "search: Output wrote to: $4"

            else
                echo "search: Path to input sequence file not found, exiting"; exit 1
            fi
        else
            echo "search: Mash sketches was not found in the same directory as the sequence database"; exit 1
        fi
    else
        echo "search: Path to database not found, exiting"; exit 1
    fi
}

# Use this to set the new config value for kipper archive database. 
function set_config(){
    echo "DB_PATH=\"$DB_PATH\"" > $cfgpath
    
    #sed -i "s/\($1 *= *\).*/\1$2/" $cfgpath
    #sed -i "s/^\($1\s*=\s*\).*\$/\1$2/" $cfgpath
}

# Show kipper db versions.
kipper_listdb() {

     # $1    database path including database name (*.fasta)
    # directory
    if [[ -d $1 ]]; then
        echo "kipper: Input path $1 is a directory, looking for *.fasta, exiting"
        exit 1
    fi

    kipper.py $1 -l
}

# Perform archival functions.
kipper_backup() {

    # $1    input database path including database name (*.fasta)
    # $2    output sequence database

    ## check integrity of input file structure
    echo "kipper: Perform archival backup function..."

    # directory
    if [[ -d $1 ]]; then
        echo "kipper: Input path $1 is a directory, looking for *.fasta, exiting"
        exit 1
    fi
 
    # If the output database does not exist, create it.
    if [[ ! -f "$2.md" ]]; then
        kipper.py $2 -M fasta
    fi

    foo="kipper.py $2 -l"
    fooIn=$($foo)

    kipper.py $2 -i $1 -o.
    
    fooOut=$($foo)
    if [ "$fooIn" = "$fooOut" ]; then
        echo "kipper: No changes"
    else
        echo "kipper: Backup complete"
    fi
}

# Perform restore function.
kipper_restore() {

    # $1    output sequence database path including database name (*.fasta)
    # $2    input archive database
    # $3    version number

    ## check integrity of input file structure
    echo "kipper: Perform archival restore function..."

    # directory
    if [[ -d $1 ]]; then
        echo "kipper: Output path $1 is a directory, looking for *.fasta, exiting"
        exit 1
    fi

    kipper.py $2 -e -n $3 -o $1
}

# unbuild database
unbuild_db() {

    # $1    input database path including database name (*.fasta)
    # $2    output parent directory path

    ## check integrity of input file structure
    echo "unbuild_db: Checking integrity of input file structure..."

    # directory
    if [[ -d $1 ]]; then
        echo "unbuild_db: Input path is a directory, looking for *.fasta, exiting"
        exit 1
    fi

    # index database to make sure it is up-to-date, then use index to extract samples.
    seqkit faidx $1

    ## deconstruct db
    echo "unbuild_db: Deconstructing local sequence database from $1..."

    sed "s/\t/\|/g" < $1.fai | while read in; 
      do 
        sample=${in%|*}
        # eg. 1616822_Hp
        id=${in#*|}
        id=${id%%|*}  
        # eg. contig_1_segment0

        if [[ ! -d $2/$sample ]]; then
            mkdir $2/$sample
        fi
        
        seqdb extract -q $sample -d $1 > $2/$sample/$id.fasta        
      done 

    echo "unbuild_db: Sample files built at $2"    
}

# build database
build_db() {

    # $1    input parent directory path
    # $2    output database path

    ## check integrity of input file structure
    echo "build_db: Checking integrity of input file structure..."

    # directory
    if [[ ! -d $1 ]]; then
        echo "build_db: Input path is not a directory, exiting"
        exit 1
    fi

    # subfolders
    samples_n=$(ls -d $1/*/ | wc -l)
    
    if [[ $samples_n -eq 0 ]]; then
        echo "build_db: No subfolders found under ${1}, exiting"
        exit 1
    else
        echo "build_db: Total samples found: $samples_n"
    fi

    ## construct sequence db
    echo "build_db: Constructing local sequence database..."
    mkdir -p $(dirname $2)/sketches

    for dir in $(ls -d $1/*/); do
        # get sample id
        sample_id=$(echo $(basename $dir))

        # check fasta file
        if test -f $dir/$sample_id.fasta; then
            # append sample ID to fasta headers and insert entry to database
            cat $dir/$sample_id.fasta | sed "/>/ s/^>/>${sample_id}|/g" >> $2
            # create kmer profile
            mash sketch -s 10000 $dir/$sample_id.fasta -o $(dirname $2)/sketches/$sample_id 2> /dev/null
        else
            echo "$sample_id.fasta not found under $dir"
            exit 1
        fi
    done

    # index sequence database

    # construct kmer db
    echo "build_db: Constructing local k-mer database..."
    seqkit faidx $2 # index

    echo "build_db: Local sequence database built at $2"    
}

extract() {

    # $1    Sample ID
    # $2    Database path
    
    if test -f $2; then
        # check sample ID
        #if [[ $(seqkit faidx -r $2 $1 | grep ">" | sed 's/;.*$//' | sed 's/>//' | awk -v var="$1" '$1==var' | wc -l) -eq 0 ]]; then
        if [[ $(seqkit faidx -r $2 "${1}\|" | grep ">" | wc -l) -eq 0 ]]; then
            # 1>&2 redirect echo output to stderr
            echo "extract: Query sample ID not found, exiting" 1>&2
            exit 1
        else
            if test -f $2; then
                seqkit grep -rp "${1}\|" $2
                #seqkit grep -rp $1 $2 | seqkit fx2tab | awk 'BEGIN{FS=OFS="\t"} {$1 = $1 OFS $1} 1' | awk 'BEGIN{FS=OFS="\t"} {gsub(/;.*/,"",$1); print}' | awk -v var="$1" '$1==var' | cut -f1 --complement -d$'\t' | seqkit tab2fx
            else
                echo "extract: Path to Database $2 does not exist, exiting" 1>&2
                exit 1
            fi
        fi
    else
        echo "extract: Path to Database $2 does not exist, exiting" 1>&2
        exit 1
    fi
}

insert() {

    # $1 Sample ID
    # $2 Input FASTA path
    # $3 Database path

    if test -f $3; then
        # check sample ID
        #if [[ $(seqkit faidx -r $3 $1 | grep ">" | sed 's/;.*$//' | sed 's/>//' | awk -v var="$1" '$1==var' | wc -l) -eq 0 ]]; then
        if [[ $(seqkit faidx -r $3 "${1}\|" | grep ">" | wc -l) -eq 0 ]]; then
            if test -f $2; then
                
                # sketch k-mer profile for insert
                if test -d $(dirname $3)/sketches; then
                    echo "insert: Generating k-mer profile for $1"
                    mash sketch -s 10000 $2 -o $(dirname $3)/sketches/$1.msh 2> /dev/null
                else
                    echo "insert: k-mer sketches directory is not found in the same directory as the input database at $(realpath $(dirname $3)), exiting"; exit 1
                fi

                echo "insert: Inserting $1 from $2 into $3"
                cat $2 | sed "/>/ s/^>/>$1|/g" >> $3
                # Invalidate the index by deleting it.
                rm $3.fai

                # reformat database to ensure equal lengths across entries
                picard NormalizeFasta -I $3 -O $3.tmp > /dev/null
                mv $3.tmp $3

                # index 
                seqkit faidx $3

                echo "insert: Complete"
            else
                echo "insert: Input FASTA file not found, exiting"
                exit 1
            fi
        else
            echo "insert: The input sample ID already exists in the database, use replace subcommand instead, exiting"
            exit 1
        fi
    else
        echo "insert: Path to Database $3 does not exist, exiting"
        exit 1
    fi
}

remove() {

    # $1 Sample ID
    # $2 Database path

    if test -f $2; then
        if [[ $(seqkit faidx -r $2 "${1}\|" | grep ">" | wc -l) -eq 0 ]]; then
            echo "remove: Query sample ID not found, exiting"
            exit 1
        else
            echo "remove: Deleting $1 from $2"
            
            if test -d $(dirname $2)/sketches; then
                rm $(dirname $2)/sketches/$1.msh
            else
                echo "remove: k-mer sketches directory is not found in the same directory as the input database at $(realpath $(dirname $3)), exiting"; exit 1
            fi
            
            seqkit grep -v -rp "${1}\|" $2 > tmp.fasta
            # $2 gets set to zero length if redirected directly.
            mv tmp.fasta $2
            # Invalidate the index by deleting it.
            rm $2.fai

            echo "remove: Complete"
            
        fi
    else
        echo "remove: Path to Database $2 does not exist, exiting"
        exit 1
    fi
}

replace() {

    # $1 Sample ID
    # $2 Input FASTA path
    # $3 Database path

    echo "replace: Modifying $1 in $3"
    remove $1 $3
    insert $1 $2 $3
}

# parse arguments
if [[ $# -eq 0 || $1 =~ ^(--help|-h) ]]; then
    script_usage
    exit 0
elif [[ ! $1 =~ ^(extract|build_db|remove|replace|insert|unbuild_db|kipper|search|build_tree)$ ]]; then
    echo "Invalid subcommand given"
    script_usage
    exit 1
fi

## check dependencies
# seqkit
seqkit -h > /dev/null
if [[ $(echo $?) -ne 0 ]]; then
    echo "Seqkit cannot be called, check its installation, exiting"
    exit 1
fi
# mash
mash sketch -h > /dev/null
if [[ $(echo $?) -ne 0 ]]; then
    echo "mash cannot be called, check its installation, exiting"
    exit 1
fi
# picard
picard -h > /dev/null
if [[ $(echo $?) -ne 0 ]]; then
    echo "picard cannot be called, check its installation, exiting"
    exit 1
fi
# kipper
kipper.py -h > /dev/null
if [[ $(echo $?) -ne 0 ]]; then
    echo "kipper cannot be called, check its installation, exiting"
    exit 1
fi
# phame
phame -h > /dev/null
if [[ $(echo $?) -ne 0 ]]; then
    echo "phame cannot be called, check its installation, exiting"
    exit 1
fi
# mashtree
mashtree -h > /dev/null
if [[ $(echo $?) -ne 0 ]]; then
    echo "mashtree cannot be called, check its installation, exiting"
    exit 1
fi

# parse subcommands
if [[ $1 == "build_db" ]]; then
    shift 1
    if [[ $# -eq 0 ]]; then
        build_db_usage
        exit 0
    fi
    opts=`getopt -o hi:o: -l help,input:,output: -- "$@"`
    eval set -- "$opts"
    if [ $? != 0 ] ; then echo "build_db: Invalid arguments used, exiting"; build_db_usage; exit 1 ; fi
    if [[ $1 =~ ^--$ ]] ; then echo "build_db: Invalid arguments used, exiting"; build_db_usage; exit 1 ; fi

    while true; do
        case "$1" in
            -i|--input) INPUT_PATH=$2; shift 2;;
            -o|--output) OUTPUT_PATH=$2; shift 2;;
            --) shift; break ;;
            -h|--help) build_db_usage; exit 0;;
        esac
    done

    # check if required arguments present
    if [[ -z $INPUT_PATH ]]; then
        echo "build_db: required argument -i is missing, exiting"; build_db_usage; exit 1
    elif [[ -z $OUTPUT_PATH ]]; then
        echo "build_db: required argument -o is missing, exiting"; build_db_usage; exit 1
    fi
    # call build_db function
    build_db $INPUT_PATH $OUTPUT_PATH    

elif 
[[ $1 == "unbuild_db" ]]; then
    shift 1
    if [[ $# -eq 0 ]]; then
        unbuild_db_usage
        exit 0
    fi
    opts=`getopt -o hi:o: -l help,input:,output: -- "$@"`
    if [ $? != 0 ] ; then echo "unbuild_db: Invalid arguments used, exiting"; unbuild_db_usage; exit 1 ; fi
    eval set -- "$opts"
    if [[ $1 =~ ^--$ ]] ; then echo "unbuild_db: Invalid arguments used, exiting"; unbuild_db_usage; exit 1 ; fi

    while true; do
        case "$1" in
            -i|--input) INPUT_PATH=$2; shift 2;;
            -o|--output) OUTPUT_PATH=$2; shift 2;;
            --) shift; break ;;
            -h|--help) unbuild_db_usage; exit 0;;
        esac
    done

    # check if required arguments present
    if [[ -z $INPUT_PATH ]]; then
        echo "unbuild_db: required argument -i is missing, exiting"; unbuild_db_usage; exit 1
    elif  [[ -z $OUTPUT_PATH ]]; then
        echo "unbuild_db: required argument -o is missing, exiting"; unbuild_db_usage; exit 1
    fi 
    # call unbuild_db function
    unbuild_db $INPUT_PATH $OUTPUT_PATH

elif 
[[ $1 == "kipper" ]]; then
    shift 1
    if [[ $# -eq 0 ]]; then
        kipper_usage
        exit 0
    fi
    opts=`getopt -o hblri:v:o:d: -l help,backup,list,restore,input:,version:,output:,database: -- "$@"`
    if [ $? != 0 ] ; then echo "kipper: Invalid arguments used, exiting"; kipper_usage; exit 1 ; fi
    eval set -- "$opts"
    if [[ $1 =~ ^--$ ]] ; then echo "kipper: Invalid arguments used, exiting"; kipper_usage; exit 1 ; fi

    backup=false
    listdb=false
    restore=false
    while true; do
        case "$1" in
            -i|--input) INPUT_PATH=$2; shift 2;;
            -o|--output) OUTPUT_PATH=$2; shift 2;;
            -d|--database) DB_PATH=$2; shift 2;;
            -v|--version) VERSION=$2; shift 2;;
            --) shift; break ;;
            -h|--help) kipper_usage; exit 0;;
            -b|--backup) backup=true; shift 1;;
            -r|--restore) restore=true; shift 1;;
            -l|--list) listdb=true; shift 1;;
        esac
    done

    if [ "$listdb" = true ]; then
        # check if required arguments present
        if [[ -z $DB_PATH ]]; then
            echo "kipper: required argument -d is missing, exiting"; kipper_usage; exit 1
        fi 

        # call kipper backup function
        kipper_listdb $DB_PATH 
    fi

    if [ "$backup" = true ]; then
        # check if required arguments present
        if [[ -z $INPUT_PATH ]]; then
            echo "kipper: required argument -i is missing, exiting"; kipper_usage; exit 1
        elif  [[ -z $DB_PATH ]]; then
            # TODO: first look for remembered db path and use if available.
            cfgpath=$(dirname $INPUT_PATH)"/kipper.cfg"

            # INITIALIZE CONFIG IF IT'S MISSING
            if [ ! -e "${cfgpath}" ] ; then
                echo "kipper: required argument -d is missing, exiting"; kipper_usage; exit 1
            fi
        fi 

        cfgpath=$(dirname $INPUT_PATH)"/kipper.cfg"
        if [ ! -e "${cfgpath}" ] ; then
            # Set default variable value
            touch $cfgpath
            echo "DB_PATH=\"$DB_PATH\"" > $cfgpath
        fi

        if  [[ -z $DB_PATH ]]; then
            # LOAD FROM THE CONFIG FILE
            source $cfgpath
            if [[ -z $DB_PATH ]]; then
                echo "kipper: required argument -d is missing from config file $cfgpath, exiting"; kipper_usage; exit 1
            fi
        fi
        set_config "DB_PATH" $DB_PATH # SETS THE NEW VALUE         
        
        # call kipper backup function
        #echo "Call Kipper $DB_PATH -i $INPUT_PATH -o."
        kipper_backup $INPUT_PATH $DB_PATH 
    fi

    if [ "$restore" = true ]; then
        # check if required arguments present
        if [[ -z $OUTPUT_PATH ]]; then
            echo "kipper: required argument -o is missing, exiting"; kipper_usage; exit 1
        fi
        if [[ -z $VERSION ]]; then
            echo "kipper: required argument -v is missing, exiting"; kipper_usage; exit 1
        fi
                
        # call kipper restore function
        echo "Restoring Kipper $DB_PATH version $VERSION to $OUTPUT_PATH."
        kipper_restore $OUTPUT_PATH $DB_PATH $VERSION
    fi

elif [[ $1 == "extract" ]]; then
    shift 1
    if [[ $# -eq 0 ]]; then
        extract_usage
        exit 0
    fi
    opts=`getopt -o hq:d: -l help,db:,query: -- "$@"`
    eval set -- "$opts"
    if [ $? != 0 ] ; then echo "extract: Invalid arguments used, exiting"; extract_usage; exit 1 ; fi
    if [[ $1 =~ ^--$ ]] ; then echo "extract: Invalid arguments used, exiting"; extract_usage; exit 1 ; fi

    while true; do
        case "$1" in
            -q|--query) QUERY=$2; shift 2;;
            -d|--db) DB_PATH=$2; shift 2;;
            --) shift; break ;;
            -h|--help) extract_usage; exit 0;;
        esac
    done

    # check if required arguments present
    if [[ -z $QUERY ]]; then
        echo "extract: required argument -q is missing, exiting"; extract_usage; exit 1
    elif [[ -z $DB_PATH ]]; then
        echo "extract: required argument -d is missing, exiting"; extract_usage; exit 1
    fi
    # call extract function
    extract $QUERY $DB_PATH

elif [[ $1 == "remove" ]]; then
    shift 1
    if [[ $# -eq 0 ]]; then
        remove_usage
        exit 0
    fi
    opts=`getopt -o hq:d: -l help,db:,query: -- "$@"`
    eval set -- "$opts"
    if [ $? != 0 ] ; then echo "remove: Invalid arguments used, exiting"; remove_usage; exit 1 ; fi
    if [[ $1 =~ ^--$ ]] ; then echo "remove: Invalid arguments used, exiting"; remove_usage; exit 1 ; fi

    while true; do
        case "$1" in
            -q|--query) QUERY=$2; shift 2;;
            -d|--db) DB_PATH=$2; shift 2;;
            --) shift; break ;;
            -h|--help) remove_usage; exit 0;;
        esac
    done

    # check if required arguments present
    if [[ -z $QUERY ]]; then 
        echo "remove: required argument -q is missing, exiting"; remove_usage; exit 1
    elif [[ -z $DB_PATH ]]; then
        echo "remove: required argument -d is missing, exiting"; remove_usage; exit 1;
    fi
    # call remove function
    remove $QUERY $DB_PATH

elif [[ $1 == "insert" ]]; then
    shift 1
    if [[ $# -eq 0 ]]; then
        insert_usage
        exit 0
    fi
    opts=`getopt -o hq:d:i: -l help,db:,query:,input: -- "$@"`
    eval set -- "$opts"
    if [ $? != 0 ] ; then echo "insert: Invalid arguments used, exiting"; insert_usage; exit 1 ; fi
    if [[ $1 =~ ^--$ ]] ; then echo "insert: Invalid arguments used, exiting"; insert_usage; exit 1 ; fi

    while true; do
        case "$1" in
            -q|--query) QUERY=$2; shift 2;;
            -d|--db) DB_PATH=$2; shift 2;;
            -i|--input) INPUT_PATH=$2; shift 2;;
            --) shift; break ;;
            -h|--help) insert_usage; exit 0;;
        esac
    done

    # check if required arguments present
    if [[ -z $QUERY ]]; then
        echo "insert: required argument -q is missing, exiting"; insert_usage; exit 1
    elif [[ -z $DB_PATH ]]; then 
        echo "insert: required argument -d is missing, exiting"; insert_usage; exit 1
    elif [[ -z $INPUT_PATH ]]; then
        echo "insert: required argument -i is missing, exiting"; insert_usage; exit 1
    fi
    # call insert function
    insert $QUERY $INPUT_PATH $DB_PATH

elif [[ $1 == "replace" ]]; then
    shift 1
    if [[ $# -eq 0 ]]; then
        replace_usage
        exit 0
    fi
    opts=`getopt -o hq:d:i: -l help,db:,query:,input: -- "$@"`
    eval set -- "$opts"
    if [ $? != 0 ] ; then echo "replace: Invalid arguments used, exiting"; replace_usage; exit 1 ; fi
    if [[ $1 =~ ^--$ ]] ; then echo "replace: Invalid arguments used, exiting"; replace_usage; exit 1 ; fi

    while true; do
        case "$1" in
            -q|--query) QUERY=$2; shift 2;;
            -d|--db) DB_PATH=$2; shift 2;;
            -i|--input) INPUT_PATH=$2; shift 2;;
            --) shift; break ;;
            -h|--help) replace_usage; exit 0;;
        esac
    done

    # check if required arguments present
    if [[ -z $QUERY ]]; then 
        echo "replace: required argument -q is missing, exiting"; replace_usage; exit 1
    elif [[ -z $DB_PATH ]]; then
        echo "replace: required argument -d is missing, exiting"; replace_usage; exit 1
    elif [[ -z $INPUT_PATH ]]; then 
        echo "replace: required argument -i is missing, exiting"; replace_usage; exit 1
    fi

    # call replace function
    replace $QUERY $INPUT_PATH $DB_PATH

elif [[ $1 == "search" ]]; then
    shift 1
    if [[ $# -eq 0 ]]; then
        search_usage
        exit 0
    fi
    opts=`getopt -o hq:d:i:o:c:t: -l help,db:,query:,input:,output:,cutoff:,threads: -- "$@"`
    eval set -- "$opts"
    if [ $? != 0 ] ; then echo "search: Invalid arguments used, exiting"; search_usage; exit 1 ; fi
    if [[ $1 =~ ^--$ ]] ; then echo "search: Invalid arguments used, exiting"; search_usage; exit 1 ; fi

    while true; do
        case "$1" in
            -q|--query) QUERY=$2; shift 2;;
            -d|--db) DB_PATH=$2; shift 2;;
            -i|--input) INPUT_PATH=$2; shift 2;;
            -o|--output) OUTPUT_PATH=$2; shift 2;;
            -c|--cutoff) CUTOFF=$2; shift 2;;
            -t|--threads) THREADS=$2; shift 2;;
            --) shift; break ;;
            -h|--help) search_usage; exit 0;;
        esac
    done

    # check if required arguments present
    if [[ -z $QUERY ]]; then 
        echo "search: required argument -q is missing, exiting"; search_usage; exit 1
    elif [[ -z $DB_PATH ]]; then
        echo "search: required argument -q is missing, exiting"; search_usage; exit 1
    elif [[ -z $INPUT_PATH ]]; then 
        echo "search: required argument -i is missing, exiting"; search_usage; exit 1
    elif [[ -z $OUTPUT_PATH ]]; then 
        echo "search: required argument -o is missing, exiting"; search_usage; exit 1
    fi

    if [[ -z $CUTOFF ]]; then CUTOFF=1; fi
    if [[ -z $THREADS ]]; then THREADS=1; fi

    # call search function
    search $QUERY $INPUT_PATH $DB_PATH $OUTPUT_PATH $CUTOFF $THREADS

elif [[ $1 == "build_tree" ]]; then
    shift 1
    if [[ $# -eq 0 ]]; then
        build_tree_usage
        exit 0
    fi
    opts=`getopt -o hd:l:o:t:r:n: -l help,db:,list:,output:,threads:,reference:,fast_tree -- "$@"`
    eval set -- "$opts"
    if [ $? != 0 ] ; then echo "build_tree: Invalid arguments used, exiting"; build_tree_usage; exit 1 ; fi
    if [[ $1 =~ ^--$ ]] ; then echo "build_tree: Invalid arguments used, exiting"; build_tree_usage; exit 1 ; fi

    while true; do
        case "$1" in
            -l|--list) INPUT_LIST=$2; shift 2;;
            -d|--db) DB_PATH=$2; shift 2;;
            -o|--output) OUTPUT_DIR=$2; shift 2;;
            -t|--threads) THREADS=$2; shift 2;;
            -r|--reference) REF_PATH=$2; shift 2;;
            --fast_tree) FAST_TREE=true; shift 1;;
            -n) N_HITS=$2; shift 2;;
            --) shift; break ;;
            -h|--help) build_tree_usage; exit 0;;
        esac
    done

    # check if required arguments present
    if [[ -z $INPUT_LIST ]]; then 
        echo "build_tree: required argument -l is missing, exiting"; build_tree_usage; exit 1
    elif [[ -z $DB_PATH ]]; then
        echo "build_tree: required argument -d is missing, exiting"; build_tree_usage; exit 1
    elif [[ -z $OUTPUT_DIR ]]; then 
        echo "build_tree: required argument -o is missing, exiting"; build_tree_usage; exit 1
    elif [[ -z $REF_PATH ]] && [[ $FAST_TREE != true ]]; then 
        echo "build_tree: required argument -r is missing, exiting"; build_tree_usage; exit 1
    fi

    if [[ -z $THREADS ]]; then THREADS=1; fi
    if [[ -z $N_HITS ]]; then N_HITS=50; fi

    # call build_tree function
    if [[ $FAST_TREE == true ]]; then
        REF_PATH=empty
        build_tree $INPUT_LIST $OUTPUT_DIR $DB_PATH $REF_PATH $THREADS $N_HITS --fast_tree
    else
        build_tree $INPUT_LIST $OUTPUT_DIR $DB_PATH $REF_PATH $THREADS $N_HITS
    fi
fi